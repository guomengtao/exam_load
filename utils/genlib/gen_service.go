package genlib

import (
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	meta "gin-go-test/utils/gen/meta"
)

// ServiceTemplateData holds data passed to the service templates.
// ServiceName is the CamelCase version of the table name used for service naming.
// ModelName is the CamelCase version of the table name used for model struct naming.
// TableName is the original table name.
// RoutePath is the lowercase version of the table name used for route paths.
// Fields is a slice of Field structs representing the table's columns.
type ServiceTemplateData struct {
	ServiceName string
	ModelName   string
	TableName   string
	RoutePath   string
	Fields      []meta.Field
}

// ensureCommonFile ensures that the common.go file exists in the service package
func ensureCommonFile() error {
	commonPath := "utils/generated/service/common.go"
	if _, err := os.Stat(commonPath); os.IsNotExist(err) {
		// Create the directory if it doesn't exist
		if err := os.MkdirAll("utils/generated/service", os.ModePerm); err != nil {
			return fmt.Errorf("åˆ›å»ºç›®å½•å¤±è´¥: %v", err)
		}

		// Create the common.go file
		commonContent := `package service

import (
	"fmt"
	"time"
)

// ErrorResponse ç”¨äºç»Ÿä¸€é”™è¯¯è¿”å›æ ¼å¼
type ErrorResponse struct {
	Code    int    ` + "`json:\"code\"`" + `
	Message string ` + "`json:\"message\"`" + `
	Details string ` + "`json:\"details,omitempty\"`" + `
	Time    string ` + "`json:\"timestamp\"`" + `
}

// NewErrorResponse åˆ›å»ºæ–°çš„é”™è¯¯å“åº”
func NewErrorResponse(code int, message string, details string) ErrorResponse {
	return ErrorResponse{
		Code:    code,
		Message: message,
		Details: details,
		Time:    time.Now().Format(time.RFC3339),
	}
}

// isZero åˆ¤æ–­ä¸€ä¸ªå­—æ®µæ˜¯å¦ä¸ºé›¶å€¼
func isZero(v interface{}) bool {
	switch val := v.(type) {
	case string:
		return val == ""
	case int, int8, int16, int32, int64:
		return fmt.Sprintf("%v", val) == "0"
	case uint, uint8, uint16, uint32, uint64:
		return fmt.Sprintf("%v", val) == "0"
	case float32, float64:
		return fmt.Sprintf("%v", val) == "0" || fmt.Sprintf("%v", val) == "0.0"
	case bool:
		return !val
	case nil:
		return true
	default:
		return v == nil
	}
}`
		if err := os.WriteFile(commonPath, []byte(commonContent), 0644); err != nil {
			return fmt.Errorf("åˆ›å»º common.go å¤±è´¥: %v", err)
		}
		fmt.Println("âœ… åˆ›å»º common.go æˆåŠŸ")
	}
	return nil
}

// cleanServiceSkeletonFiles removes the service skeleton file for the given table
func cleanServiceSkeletonFiles(tableName string) error {
	dir := "utils/generated/service"
	file := filepath.Join(dir, fmt.Sprintf("%s_service_skeleton.go", tableName))
	if err := os.Remove(file); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("åˆ é™¤æ–‡ä»¶å¤±è´¥ %s: %v", file, err)
	}
	fmt.Printf("ğŸ—‘ï¸ å·²åˆ é™¤: %s\n", file)
	return nil
}

// GenerateServiceFromTable generates a service file from a table name.
// It converts tableName to CamelCase for both ServiceName and ModelName.
func GenerateServiceFromTable(tableName string) error {
	serviceName := toCamelCase(tableName)
	modelName := toCamelCase(tableName)
	routePath := strings.ToLower(tableName)

	// æ–°å¢ï¼šè·å–æ•°æ®åº“è¿æ¥å’Œè¡¨å­—æ®µ
	db, err := meta.GetDBFromEnv()
	if err != nil {
		return fmt.Errorf("è·å–æ•°æ®åº“è¿æ¥å¤±è´¥: %v", err)
	}
	defer db.Close()

	// è‡ªåŠ¨è¯»å–è¡¨å‰ç¼€
	tablePrefix := os.Getenv("TABLE_PREFIX")
	fullTableName := tableName
	if tablePrefix != "" {
		fullTableName = tablePrefix + tableName
	}

	fields, err := meta.FetchTableFields(db, fullTableName)
	if err != nil {
		return fmt.Errorf("è·å–è¡¨å­—æ®µå¤±è´¥: %v", err)
	}

	data := ServiceTemplateData{
		ServiceName: serviceName,
		ModelName:   modelName,
		TableName:   tableName,
		RoutePath:   routePath,
		Fields:      fields, // ä¼ é€’å­—æ®µ
	}

	tmpl, err := template.ParseFiles("utils/gen/templates/service.tpl")
	if err != nil {
		return fmt.Errorf("åŠ è½½æ¨¡æ¿å¤±è´¥: %v", err)
	}

	outputPath := fmt.Sprintf("app/services/%s_service.go", tableName)
	if err := os.MkdirAll("app/services", os.ModePerm); err != nil {
		return err
	}

	outFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæœåŠ¡æ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer outFile.Close()

	// æ–‡ä»¶å¤´éƒ¨åŠ è‡ªåŠ¨ç”Ÿæˆæ³¨é‡Š
	outFile.WriteString("// Code generated by gen.go. DO NOT EDIT.\n")

	if err := tmpl.Execute(outFile, data); err != nil {
		return fmt.Errorf("æ¸²æŸ“æ¨¡æ¿å¤±è´¥: %v", err)
	}

	return nil
}

// GenerateServiceSkeleton generates a service skeleton file from a table name.
// It converts tableName to CamelCase for both ServiceName and ModelName.
func GenerateServiceSkeleton(db *sql.DB, tableName string, tmpl *template.Template) error {
	// ç¡®ä¿ common.go å­˜åœ¨
	if err := ensureCommonFile(); err != nil {
		return fmt.Errorf("ç¡®ä¿ common.go å­˜åœ¨å¤±è´¥: %v", err)
	}

	// æ¸…ç†ç°æœ‰çš„æœåŠ¡éª¨æ¶æ–‡ä»¶
	if err := cleanServiceSkeletonFiles(tableName); err != nil {
		return fmt.Errorf("æ¸…ç†æœåŠ¡éª¨æ¶æ–‡ä»¶å¤±è´¥: %v", err)
	}

	serviceName := toCamelCase(tableName)
	modelName := toCamelCase(tableName)

	// è¯»å–å‰ç¼€å¹¶æ‹¼æ¥å®Œæ•´è¡¨å
	tablePrefix := os.Getenv("TABLE_PREFIX")
	fullTableName := tableName
	if tablePrefix != "" {
		fullTableName = tablePrefix + tableName
	}

	// 1. è·å–å­—æ®µä¿¡æ¯
	fields, err := meta.FetchTableFields(db, fullTableName)
	if err != nil {
		return fmt.Errorf("âŒ è·å–å­—æ®µä¿¡æ¯å¤±è´¥: %v", err)
	}

	// 2. æ ¡éªŒè‡³å°‘æœ‰ä¸€ä¸ªå¿…å¡«å­—æ®µ
	var primaryField string
	for _, f := range fields {
		if f.IsRequired {
			primaryField = f.Name
			break
		}
	}
	if primaryField == "" {
		fmt.Printf("âš ï¸ è­¦å‘Šï¼šè¡¨ %s æ²¡æœ‰ä»»ä½•å¿…å¡«å­—æ®µï¼Œè¯·ä¸ºè‡³å°‘ä¸€ä¸ªå­—æ®µè®¾ç½® NOT NULL\n", tableName)
		primaryField = "Id"
	}

	// 3. ç»„è£…æ¨¡æ¿æ•°æ®
	data := map[string]interface{}{
		"ServiceName":  serviceName,
		"ModelName":    modelName,
		"PrimaryField": primaryField,
		"Fields":       fields,
	}

	outputPath := fmt.Sprintf("utils/generated/service/%s_service_skeleton.go", tableName)
	if err := os.MkdirAll("utils/generated/service", os.ModePerm); err != nil {
		return err
	}

	outFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºéª¨æ¶æ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer outFile.Close()

	if err := tmpl.Execute(outFile, data); err != nil {
		return fmt.Errorf("æ¸²æŸ“éª¨æ¶æ¨¡æ¿å¤±è´¥: %v", err)
	}

	return nil
}