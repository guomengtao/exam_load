package main_back

import (
	"database/sql"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	"github.com/joho/godotenv"
)

// Column represents a database column metadata
type Column struct {
	ColumnName string
	DataType   string
	IsNullable string
	ColumnKey  string
}

// typeMapping maps MySQL data types to Go types
var typeMapping = map[string]string{
	"int":       "int",
	"tinyint":   "int8",
	"smallint":  "int16",
	"mediumint": "int32",
	"bigint":    "int64",
	"varchar":   "string",
	"char":      "string",
	"text":      "string",
	"longtext":  "string",
	"datetime":  "time.Time",
	"timestamp": "time.Time",
	"date":      "time.Time",
	"float":     "float32",
	"double":    "float64",
	"decimal":   "float64",
	"bool":      "bool",
	"boolean":   "bool",
}

// mysqlTypeToGoType converts MySQL type to Go type
func mysqlTypeToGoType(mysqlType string) string {
	baseType := mysqlType
	if idx := strings.Index(mysqlType, "("); idx != -1 {
		baseType = mysqlType[:idx]
	}
	baseType = strings.ToLower(baseType)
	if goType, ok := typeMapping[baseType]; ok {
		return goType
	}
	return "string"
}

// camelCase converts snake_case to CamelCase
func camelCase(input string) string {
	parts := strings.Split(input, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// containsTime checks if any column requires importing "time"
func containsTime(cols []Column) bool {
	for _, col := range cols {
		goType := mysqlTypeToGoType(col.DataType)
		if goType == "time.Time" {
			return true
		}
	}
	return false
}

// generateAppModel generates model file inside app/models directory
func generateAppModel(table string, columns []Column) error {
	var sb strings.Builder

	// Package declaration
	sb.WriteString("package models\n\n")

	// Import time if needed
	if containsTime(columns) {
		sb.WriteString("import \"time\"\n\n")
	}

	structName := camelCase(table)
	sb.WriteString(fmt.Sprintf("// %s defines the model for the %s table\n", structName, table))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, col := range columns {
		goType := mysqlTypeToGoType(col.DataType)
		fieldName := camelCase(col.ColumnName)
		jsonTag := col.ColumnName
		gormTag := fmt.Sprintf("column:%s", col.ColumnName)
		if col.ColumnKey == "PRI" {
			gormTag += ";primaryKey"
		}
		sb.WriteString(fmt.Sprintf("    %s %s `gorm:\"%s\" json:\"%s\"`\n", fieldName, goType, gormTag, jsonTag))
	}
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("func (%s) TableName() string {\n", structName))
	sb.WriteString(fmt.Sprintf("    return \"%s\"\n", table))
	sb.WriteString("}\n")

	path := fmt.Sprintf("app/models/%s.go", table)
	dir := "app/models"
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s': %w", dir, err)
	}

	log.Printf("Generating app model file at: %s\n", path)
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// generateModel generates model file inside utils/generated/models directory
func generateModel(table string, columns []Column) error {
	var sb strings.Builder

	sb.WriteString("package generated\n\n")

	if containsTime(columns) {
		sb.WriteString("import \"time\"\n\n")
	}

	structName := camelCase(table)
	sb.WriteString(fmt.Sprintf("// %s defines the model for the %s table\n", structName, table))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, col := range columns {
		goType := mysqlTypeToGoType(col.DataType)
		fieldName := camelCase(col.ColumnName)
		jsonTag := col.ColumnName
		gormTag := fmt.Sprintf("column:%s", col.ColumnName)
		if col.ColumnKey == "PRI" {
			gormTag += ";primaryKey"
		}
		sb.WriteString(fmt.Sprintf("    %s %s `gorm:\"%s\" json:\"%s\"`\n", fieldName, goType, gormTag, jsonTag))
	}
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("func (%s) TableName() string {\n", structName))
	sb.WriteString(fmt.Sprintf("    return \"%s\"\n", table))
	sb.WriteString("}\n")

	dir := "utils/generated/models"
	path := fmt.Sprintf("%s/%s.go", dir, table)

	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s': %w", dir, err)
	}

	log.Printf("Writing generated model file to: %s\n", path)
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// generateService generates service file inside utils/generated/services directory
func generateService(table string) error {
	structName := camelCase(table)
	content := fmt.Sprintf(`package generated

// %sService defines service for %s model
type %sService struct {}

func New%sService() *%sService {
	return &%sService{}
}

// TODO: Add CRUD methods here for %s
func (s *%sService) Example() {
	// Placeholder for %s service methods
}
`, structName, table, structName, structName, structName, structName, table, structName, structName)

	dir := "utils/generated/services"
	path := fmt.Sprintf("%s/%s_service.go", dir, table)

	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s': %w", dir, err)
	}

	log.Printf("Writing generated service file to: %s\n", path)
	return os.WriteFile(path, []byte(content), 0644)
}

// generateServiceTest generates service test file inside utils/generated/services directory
func generateServiceTest(table string) error {
	structName := camelCase(table)
	content := fmt.Sprintf(`package generated

import (
	"testing"
)

func Test%sService_Example(t *testing.T) {
	service := New%sService()
	service.Example()
}
`, structName, structName)

	dir := "utils/generated/services"
	path := fmt.Sprintf("%s/%s_service_test.go", dir, table)

	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s': %w", dir, err)
	}

	log.Printf("Writing generated service test file to: %s\n", path)
	return os.WriteFile(path, []byte(content), 0644)
}

// generateBiz generates business logic file inside utils/generated/services directory
func generateBiz(table string) error {
	structName := camelCase(table)
	content := fmt.Sprintf(`package generated

// %sBiz provides business logic layer for %s
type %sBiz struct {}

var %sServiceInstance = New%sService()

func New%sBiz() *%sBiz {
	return &%sBiz{}
}

// ExampleBizMethod demonstrates calling service method from biz layer
func (b *%sBiz) ExampleBizMethod() {
	// Calling service method from biz layer
	%sServiceInstance.Example()
}
`, structName, table, structName, structName, structName, structName, structName, structName, structName, structName)

	dir := "utils/generated/services"
	path := fmt.Sprintf("%s/%s_biz.go", dir, table)

	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s': %w", dir, err)
	}

	log.Printf("Generating business service file at: %s\n", path)
	return os.WriteFile(path, []byte(content), 0644)
}


// generateAppServiceTest generates service test file inside app/services directory
func generateAppServiceTest(table string) error {
	structName := camelCase(table)
	content := fmt.Sprintf(`package services

import (
	"testing"

	gen "gin-go-test/utils/generated/services"
)

func Test%sBiz_Example(t *testing.T) {
	biz := New%sBiz()
	biz.ExampleBizMethod()
}
`, structName, structName)

	dir := "app/services"
	path := fmt.Sprintf("%s/%s_service_test.go", dir, table)

	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s': %w", dir, err)
	}

	log.Printf("Generating app service test file at: %s\n", path)
	return os.WriteFile(path, []byte(content), 0644)
}

// fetchColumns retrieves column metadata from the database
func fetchColumns(db *sql.DB, schema, table string) ([]Column, error) {
	query := `SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_KEY
        FROM information_schema.COLUMNS
        WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
        ORDER BY ORDINAL_POSITION`
	rows, err := db.Query(query, schema, table)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var cols []Column
	for rows.Next() {
		var c Column
		if err := rows.Scan(&c.ColumnName, &c.DataType, &c.IsNullable, &c.ColumnKey); err != nil {
			return nil, err
		}
		cols = append(cols, c)
	}
	return cols, nil
}

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Printf("Warning: Could not load .env file: %v\n", err)
	}

	table := flag.String("table", "", "Table name to generate")
	genType := flag.String("type", "all", "Type of code to generate: model, service, or all")
	genBiz := flag.Bool("genbiz", false, "Generate business service file")
	clearCache := flag.Bool("clearcache", false, "Clear cache and exit")

	dbUser := flag.String("dbuser", "", "Database user")
	dbPass := flag.String("dbpass", "", "Database password")
	dbHost := flag.String("dbhost", "", "Database host")
	dbPort := flag.String("dbport", "", "Database port")
	dbName := flag.String("dbname", "", "Database name")

	flag.Parse()

	if *clearCache {
		log.Printf("Cache cleared (simulated). Exiting.\n")
		return
	}

	// Set database configuration from environment variables if not provided
	if *dbUser == "" {
		*dbUser = os.Getenv("MYSQL_USER")
		if *dbUser == "" {
			*dbUser = "root"
		}
	}
	if *dbPass == "" {
		*dbPass = os.Getenv("MYSQL_PASSWORD")
	}
	if *dbHost == "" {
		*dbHost = os.Getenv("MYSQL_HOST")
		if *dbHost == "" {
			*dbHost = "127.0.0.1"
		}
	}
	if *dbPort == "" {
		*dbPort = os.Getenv("MYSQL_PORT")
		if *dbPort == "" {
			*dbPort = "3306"
		}
	}
	if *dbName == "" {
		*dbName = os.Getenv("MYSQL_DB")
	}

	// Validate required flags
	if *table == "" {
		log.Printf("Error: --table flag is required\n")
		flag.Usage()
		os.Exit(1)
	}
	if *dbName == "" {
		log.Printf("Error: --dbname flag or MYSQL_DB environment variable is required\n")
		flag.Usage()
		os.Exit(1)
	}

	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		*dbUser, *dbPass, *dbHost, *dbPort, *dbName)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v\n", err)
	}
	defer db.Close()

	columns, err := fetchColumns(db, *dbName, *table)
	if err != nil {
		log.Fatalf("Failed to fetch columns for table '%s': %v\n", *table, err)
	}

	t := strings.ToLower(*genType)
	switch t {
	case "model":
		if err := generateModel(*table, columns); err != nil {
			log.Fatalf("Error generating model: %v\n", err)
		}
		if err := generateAppModel(*table, columns); err != nil {
			log.Fatalf("Error generating app model: %v\n", err)
		}
	case "service":
		if err := generateService(*table); err != nil {
			log.Fatalf("Error generating service: %v\n", err)
		}
		if err := generateServiceTest(*table); err != nil {
			log.Fatalf("Error generating service test: %v\n", err)
		}
		if err := generateAppServiceTest(*table); err != nil {
			log.Fatalf("Error generating app service test: %v\n", err)
		}
	case "all":
		if err := generateModel(*table, columns); err != nil {
			log.Fatalf("Error generating model: %v\n", err)
		}
		if err := generateAppModel(*table, columns); err != nil {
			log.Fatalf("Error generating app model: %v\n", err)
		}
		if err := generateService(*table); err != nil {
			log.Fatalf("Error generating service: %v\n", err)
		}
		if err := generateServiceTest(*table); err != nil {
			log.Fatalf("Error generating service test: %v\n", err)
		}
		if err := generateAppServiceTest(*table); err != nil {
			log.Fatalf("Error generating app service test: %v\n", err)
		}
	default:
		log.Printf("Invalid --type value '%s'. Must be one of: model, service, all\n", *genType)
		flag.Usage()
		os.Exit(1)
	}

	if *genBiz {
		log.Printf("Generating business service for table '%s'\n", *table)
		if err := generateBiz(*table); err != nil {
			log.Fatalf("Error generating business service: %v\n", err)
		}
	}

}